module Test.Main where

import Prelude

--import Debug.Trace
--import Control.Apply ((*>))
--import Control.Monad.Aff (Aff(), launchAff)
--import Control.Monad.Eff.Class (liftEff)
--import Control.Monad.Eff (Eff())
import Control.Monad.Eff.Console (log)
--import Control.Monad.ST (ST())
--import Control.Monad.Eff.Random (randomInt)
--import Data.Array ((:), head, length, drop, take, zipWith, nub, sort, reverse)
--import Data.Array.ST (freeze, thaw)
--import Data.Either (Either(..), either)
--import Data.Functor (($>))
--import Data.Foldable (foldl)
--import Data.Generic (Generic, gEq, gShow)
--import Data.Maybe (maybe, Maybe(..))
--import Data.Tuple (Tuple(..))
--import Data.Tuple.Nested (uncurry3)
--
--import Test.AsyncCheck (asyncCheck)
--import qualified Test.Coroutine (collect, take, check, maybeCallback) as C
--import Test.Helpers (stubGet)
--import Test.StrongCheck (Arbitrary, arbitrary)
--import Test.StrongCheck.Gen (suchThat)
--
--import Control.Coroutine
--
--import Control.Coroutine.Aff.Seq
--
--newtype AtLeastTwoAndUnique a = AtLeastTwoAndUnique (Tuple (Tuple a a) (Array a))
--
--runAtLeastTwoAndUnique :: forall a. AtLeastTwoAndUnique a -> { fst :: a, snd :: a, xs :: Array a }
--runAtLeastTwoAndUnique (AtLeastTwoAndUnique tuple) = (uncurry3 { fst: _, snd: _, xs: _ }) tuple
--
--instance arbAtLeastTwoAndUnique :: (Arbitrary a, Ord a, Show a) => Arbitrary (AtLeastTwoAndUnique a) where
--  arbitrary = AtLeastTwoAndUnique `map` (arbitrary `suchThat` (unique `compose` toArray))
--    where
--    unique xs = nub xs `eq` xs
--    toArray (Tuple (Tuple x1 x2) xs) = x1 : x2 : xs
--
--newtype BestThing = BestThing { since :: String, name :: String }
--
--derive instance genericBestThing :: Generic BestThing
--
---- exampleBestThing = BestThing { since: "Sliced Bread", name: "PureScript" }
--
--fromNames :: Array String -> Array BestThing
--fromNames names = zipWith (\s n -> BestThing { since: s, name: n }) names (drop 1 names)
--
--getBestThing :: forall a eff. Array (Either a BestThing) -> String -> Aff eff (Either a BestThing)
--getBestThing = stubGet (\since -> either (const true) (\(BestThing obj) -> since == obj.since))
--
--main = do
--  log "produceSeq:" *> do
--    asyncCheck "Should produce results sequentially." \done atLeastTwoUniqueNames x -> do
--      let names = runAtLeastTwoAndUnique atLeastTwoUniqueNames
--      let bestThings = fromNames $ names.fst : names.snd : names.xs
--
--      let getter = getBestThing (Right <$> bestThings)
--      let pluckSeq (BestThing obj) = obj.name
--      let initialSeq = names.fst
--
--      let produceBestThings = produceSeq getter pluckSeq initialSeq
--      let check = C.check (length bestThings) (gEq bestThings)
--      let doneWhenAllProduced = C.maybeCallback (liftEff <<< done)
--
--      launchAff $ runProcess (produceBestThings $~ check $$ doneWhenAllProduced)
--
--    --asyncCheck "Should finish with an error when getter gets a left." \done atLeastTwoUniqueNames -> do
--    --  let 
--    --  let names = runAtLeastTwoAndUnique atLeastTwoUniqueNames
--    --  let bestThings = fromNames $ names.fst : names.snd : names.xs
--
--    --  n <- randomInt 0 $ length bestThings
--    --  let rights = Right <$> bestThings
--    --  let left = Left (err :: String)
--    --  let results = take n rights <> [left] <> drop n rights
--
--    --  let getter = getBestThing (Right <$> bestThings)
--    --  let pluckSeq (BestThing obj) = obj.name
--    --  let initialSeq = names.fst
--
--    --  let produceBestThings = produceSeq getter pluckSeq initialSeq
--    --  let check = C.check (n + 1) (gEq (take n bestThings))
--    --  let = consumer (return unit ($> Nothing))
--
--    --  launchAff $ runProcess (produceBestThings $~ check $$ doneWhenAllProduced) >>= done <<< eq err
--
--    -- Should fail when getter fails

main = log "hi"
